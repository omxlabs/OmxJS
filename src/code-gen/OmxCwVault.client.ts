/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Uint128, InstantiateMsg, ExecuteMsg, Addr, BuyUsdoMsg, SetIsLiquidatorMsg, AddRouterMsg, BuyUsdoCbMsg, ClearTokenConfigMsg, DecreasePositionMsg, DirectPoolDepositMsg, IncreasePositionMsg, LiquidatePositionMsg, SetRouterMsg, SellUsdoMsg, SellUsdoCbMsg, SetFeesMsg, Duration, SetFundingRateMsg, SetTokenConfigMsg, SetUsdoAmountMsg, SwapMsg, UpdateCumulativeFundingRateMsg, WithdrawFeesMsg, SetInManagerModeMsg, SetInPrivateLiquidationModeMsg, SetIsSwapEnabledMsg, SetIsLeverageEnabledMsg, SetMaxGasPriceMsg, SetMaxGlobalShortPriceMsg, SetManagerMsg, SetAdminMsg, QueryMsg, Timestamp, Uint64, UtilizationQuery, CumulativeFundingRatesQuery, PositionLeverageQuery, TokenToUsdMinQuery, GlobalShortAveragePricesQuery, GlobalShortSizesQuery, PositionDeltaQuery, ReservedAmountsQuery, GuaranteedUsdQuery, UsdoAmountQuery, EntryFundingRateQuery, NextGlobalShortAveragePriceQuery, NextFundingRateQuery, FundingFeeQuery, MinPriceQuery, MaxPriceQuery, RedemptionAmountQuery, TargetUsdoAmountQuery, AdjustForDecimalsQuery, IsRouterApprovedQuery, GetDeltaQuery, RedemptionCollateralQuery, RedemptionCollateralUsdQuery, PositionFeeQuery, MaxGlobalShortPriceQuery, NextAveragePriceQuery, IsManagerQuery, PoolAmountQuery, AllWhitelistedTokensQuery, WhitelistedTokenQuery, PositionsQuery, PositionQuery, FeeReservesQuery, ValidateLiquidationQuery, AllWhitelistedTokensAmountQuery, MigrateMsg, Uint32, DeltaResult, Boolean, Position, ArrayOfPositionKey, PositionKey, VaultConfig, VaultState, WhitelistedToken } from "./OmxCwVault.types";
export interface OmxCwVaultReadOnlyInterface {
  contractAddress: string;
  vaultState: () => Promise<VaultState>;
  vaultConfig: () => Promise<VaultConfig>;
  utilization: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  cumulativeFundingRates: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  positionLeverage: ({
    account,
    collateralToken,
    indexToken,
    isLong
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
  }) => Promise<Uint128>;
  tokenToUsdMin: ({
    amount,
    token
  }: {
    amount: Uint128;
    token: string;
  }) => Promise<Uint128>;
  globalShortAveragePrices: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  globalShortSizes: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  positionDelta: ({
    account,
    collateralToken,
    indexToken,
    isLong
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
  }) => Promise<DeltaResult>;
  reservedAmounts: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  guaranteedUsd: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  usdoAmount: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  entryFundingRate: ({
    collateralToken,
    indexToken,
    isLong
  }: {
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
  }) => Promise<Uint128>;
  nextGlobalShortAveragePrice: ({
    indexToken,
    nextPrice,
    sizeDelta
  }: {
    indexToken: string;
    nextPrice: Uint128;
    sizeDelta: Uint128;
  }) => Promise<Uint128>;
  nextFundingRate: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  fundingFee: ({
    collateralToken,
    entryFundingRate,
    size
  }: {
    collateralToken: string;
    entryFundingRate: Uint128;
    size: Uint128;
  }) => Promise<Uint128>;
  minPrice: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  maxPrice: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  redemptionAmount: ({
    token,
    usdoAmount
  }: {
    token: string;
    usdoAmount: Uint128;
  }) => Promise<Uint128>;
  targetUsdoAmount: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  adjustForDecimals: ({
    amount,
    tokenDiv,
    tokenMul
  }: {
    amount: Uint128;
    tokenDiv: string;
    tokenMul: string;
  }) => Promise<Uint128>;
  isRouterApproved: ({
    account,
    router
  }: {
    account: string;
    router: string;
  }) => Promise<Boolean>;
  getDelta: ({
    averagePrice,
    indexToken,
    isLong,
    lastIncreasedTime,
    size
  }: {
    averagePrice: Uint128;
    indexToken: string;
    isLong: boolean;
    lastIncreasedTime: Timestamp;
    size: Uint128;
  }) => Promise<DeltaResult>;
  redemptionCollateral: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  redemptionCollateralUsd: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  positionFee: ({
    account,
    collateralToken,
    indexToken,
    isLong,
    sizeDelta
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
    sizeDelta: Uint128;
  }) => Promise<Uint128>;
  maxGlobalShortPrice: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  nextAveragePrice: ({
    averagePrice,
    indexToken,
    isLong,
    lastIncreasedTime,
    nextPrice,
    size,
    sizeDelta
  }: {
    averagePrice: Uint128;
    indexToken: string;
    isLong: boolean;
    lastIncreasedTime: Timestamp;
    nextPrice: Uint128;
    size: Uint128;
    sizeDelta: Uint128;
  }) => Promise<Uint128>;
  isManager: ({
    addr
  }: {
    addr: string;
  }) => Promise<Boolean>;
  poolAmount: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  allWhitelistedTokens: ({
    index
  }: {
    index: number;
  }) => Promise<Addr>;
  whitelistedToken: ({
    token
  }: {
    token: string;
  }) => Promise<WhitelistedToken>;
  positions: ({
    account,
    collateralToken,
    indexToken,
    isLong,
    valid
  }: {
    account?: string;
    collateralToken?: string;
    indexToken?: string;
    isLong?: boolean;
    valid?: boolean;
  }) => Promise<ArrayOfPositionKey>;
  position: ({
    account,
    collateralToken,
    indexToken,
    isLong
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
  }) => Promise<Position>;
  feeReserves: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  validateLiquidation: ({
    account,
    collateralToken,
    indexToken,
    isLong,
    shouldRaise
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
    shouldRaise: boolean;
  }) => Promise<Uint128>;
  allWhitelistedTokensAmount: () => Promise<Uint32>;
}
export class OmxCwVaultQueryClient implements OmxCwVaultReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.vaultState = this.vaultState.bind(this);
    this.vaultConfig = this.vaultConfig.bind(this);
    this.utilization = this.utilization.bind(this);
    this.cumulativeFundingRates = this.cumulativeFundingRates.bind(this);
    this.positionLeverage = this.positionLeverage.bind(this);
    this.tokenToUsdMin = this.tokenToUsdMin.bind(this);
    this.globalShortAveragePrices = this.globalShortAveragePrices.bind(this);
    this.globalShortSizes = this.globalShortSizes.bind(this);
    this.positionDelta = this.positionDelta.bind(this);
    this.reservedAmounts = this.reservedAmounts.bind(this);
    this.guaranteedUsd = this.guaranteedUsd.bind(this);
    this.usdoAmount = this.usdoAmount.bind(this);
    this.entryFundingRate = this.entryFundingRate.bind(this);
    this.nextGlobalShortAveragePrice = this.nextGlobalShortAveragePrice.bind(this);
    this.nextFundingRate = this.nextFundingRate.bind(this);
    this.fundingFee = this.fundingFee.bind(this);
    this.minPrice = this.minPrice.bind(this);
    this.maxPrice = this.maxPrice.bind(this);
    this.redemptionAmount = this.redemptionAmount.bind(this);
    this.targetUsdoAmount = this.targetUsdoAmount.bind(this);
    this.adjustForDecimals = this.adjustForDecimals.bind(this);
    this.isRouterApproved = this.isRouterApproved.bind(this);
    this.getDelta = this.getDelta.bind(this);
    this.redemptionCollateral = this.redemptionCollateral.bind(this);
    this.redemptionCollateralUsd = this.redemptionCollateralUsd.bind(this);
    this.positionFee = this.positionFee.bind(this);
    this.maxGlobalShortPrice = this.maxGlobalShortPrice.bind(this);
    this.nextAveragePrice = this.nextAveragePrice.bind(this);
    this.isManager = this.isManager.bind(this);
    this.poolAmount = this.poolAmount.bind(this);
    this.allWhitelistedTokens = this.allWhitelistedTokens.bind(this);
    this.whitelistedToken = this.whitelistedToken.bind(this);
    this.positions = this.positions.bind(this);
    this.position = this.position.bind(this);
    this.feeReserves = this.feeReserves.bind(this);
    this.validateLiquidation = this.validateLiquidation.bind(this);
    this.allWhitelistedTokensAmount = this.allWhitelistedTokensAmount.bind(this);
  }

  vaultState = async (): Promise<VaultState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      vault_state: {}
    });
  };
  vaultConfig = async (): Promise<VaultConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      vault_config: {}
    });
  };
  utilization = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      utilization: {
        token
      }
    });
  };
  cumulativeFundingRates = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      cumulative_funding_rates: {
        token
      }
    });
  };
  positionLeverage = async ({
    account,
    collateralToken,
    indexToken,
    isLong
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position_leverage: {
        account,
        collateral_token: collateralToken,
        index_token: indexToken,
        is_long: isLong
      }
    });
  };
  tokenToUsdMin = async ({
    amount,
    token
  }: {
    amount: Uint128;
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_to_usd_min: {
        amount,
        token
      }
    });
  };
  globalShortAveragePrices = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      global_short_average_prices: {
        token
      }
    });
  };
  globalShortSizes = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      global_short_sizes: {
        token
      }
    });
  };
  positionDelta = async ({
    account,
    collateralToken,
    indexToken,
    isLong
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
  }): Promise<DeltaResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position_delta: {
        account,
        collateral_token: collateralToken,
        index_token: indexToken,
        is_long: isLong
      }
    });
  };
  reservedAmounts = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reserved_amounts: {
        token
      }
    });
  };
  guaranteedUsd = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      guaranteed_usd: {
        token
      }
    });
  };
  usdoAmount = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      usdo_amount: {
        token
      }
    });
  };
  entryFundingRate = async ({
    collateralToken,
    indexToken,
    isLong
  }: {
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      entry_funding_rate: {
        collateral_token: collateralToken,
        index_token: indexToken,
        is_long: isLong
      }
    });
  };
  nextGlobalShortAveragePrice = async ({
    indexToken,
    nextPrice,
    sizeDelta
  }: {
    indexToken: string;
    nextPrice: Uint128;
    sizeDelta: Uint128;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      next_global_short_average_price: {
        index_token: indexToken,
        next_price: nextPrice,
        size_delta: sizeDelta
      }
    });
  };
  nextFundingRate = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      next_funding_rate: {
        token
      }
    });
  };
  fundingFee = async ({
    collateralToken,
    entryFundingRate,
    size
  }: {
    collateralToken: string;
    entryFundingRate: Uint128;
    size: Uint128;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      funding_fee: {
        collateral_token: collateralToken,
        entry_funding_rate: entryFundingRate,
        size
      }
    });
  };
  minPrice = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      min_price: {
        token
      }
    });
  };
  maxPrice = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      max_price: {
        token
      }
    });
  };
  redemptionAmount = async ({
    token,
    usdoAmount
  }: {
    token: string;
    usdoAmount: Uint128;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      redemption_amount: {
        token,
        usdo_amount: usdoAmount
      }
    });
  };
  targetUsdoAmount = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      target_usdo_amount: {
        token
      }
    });
  };
  adjustForDecimals = async ({
    amount,
    tokenDiv,
    tokenMul
  }: {
    amount: Uint128;
    tokenDiv: string;
    tokenMul: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      adjust_for_decimals: {
        amount,
        token_div: tokenDiv,
        token_mul: tokenMul
      }
    });
  };
  isRouterApproved = async ({
    account,
    router
  }: {
    account: string;
    router: string;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_router_approved: {
        account,
        router
      }
    });
  };
  getDelta = async ({
    averagePrice,
    indexToken,
    isLong,
    lastIncreasedTime,
    size
  }: {
    averagePrice: Uint128;
    indexToken: string;
    isLong: boolean;
    lastIncreasedTime: Timestamp;
    size: Uint128;
  }): Promise<DeltaResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delta: {
        average_price: averagePrice,
        index_token: indexToken,
        is_long: isLong,
        last_increased_time: lastIncreasedTime,
        size
      }
    });
  };
  redemptionCollateral = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      redemption_collateral: {
        token
      }
    });
  };
  redemptionCollateralUsd = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      redemption_collateral_usd: {
        token
      }
    });
  };
  positionFee = async ({
    account,
    collateralToken,
    indexToken,
    isLong,
    sizeDelta
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
    sizeDelta: Uint128;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position_fee: {
        account,
        collateral_token: collateralToken,
        index_token: indexToken,
        is_long: isLong,
        size_delta: sizeDelta
      }
    });
  };
  maxGlobalShortPrice = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      max_global_short_price: {
        token
      }
    });
  };
  nextAveragePrice = async ({
    averagePrice,
    indexToken,
    isLong,
    lastIncreasedTime,
    nextPrice,
    size,
    sizeDelta
  }: {
    averagePrice: Uint128;
    indexToken: string;
    isLong: boolean;
    lastIncreasedTime: Timestamp;
    nextPrice: Uint128;
    size: Uint128;
    sizeDelta: Uint128;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      next_average_price: {
        average_price: averagePrice,
        index_token: indexToken,
        is_long: isLong,
        last_increased_time: lastIncreasedTime,
        next_price: nextPrice,
        size,
        size_delta: sizeDelta
      }
    });
  };
  isManager = async ({
    addr
  }: {
    addr: string;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_manager: {
        addr
      }
    });
  };
  poolAmount = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool_amount: {
        token
      }
    });
  };
  allWhitelistedTokens = async ({
    index
  }: {
    index: number;
  }): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_whitelisted_tokens: {
        index
      }
    });
  };
  whitelistedToken = async ({
    token
  }: {
    token: string;
  }): Promise<WhitelistedToken> => {
    return this.client.queryContractSmart(this.contractAddress, {
      whitelisted_token: {
        token
      }
    });
  };
  positions = async ({
    account,
    collateralToken,
    indexToken,
    isLong,
    valid
  }: {
    account?: string;
    collateralToken?: string;
    indexToken?: string;
    isLong?: boolean;
    valid?: boolean;
  }): Promise<ArrayOfPositionKey> => {
    return this.client.queryContractSmart(this.contractAddress, {
      positions: {
        account,
        collateral_token: collateralToken,
        index_token: indexToken,
        is_long: isLong,
        valid
      }
    });
  };
  position = async ({
    account,
    collateralToken,
    indexToken,
    isLong
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
  }): Promise<Position> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position: {
        account,
        collateral_token: collateralToken,
        index_token: indexToken,
        is_long: isLong
      }
    });
  };
  feeReserves = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee_reserves: {
        token
      }
    });
  };
  validateLiquidation = async ({
    account,
    collateralToken,
    indexToken,
    isLong,
    shouldRaise
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
    shouldRaise: boolean;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      validate_liquidation: {
        account,
        collateral_token: collateralToken,
        index_token: indexToken,
        is_long: isLong,
        should_raise: shouldRaise
      }
    });
  };
  allWhitelistedTokensAmount = async (): Promise<Uint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_whitelisted_tokens_amount: {}
    });
  };
}
export interface OmxCwVaultInterface extends OmxCwVaultReadOnlyInterface {
  contractAddress: string;
  sender: string;
  buyUsdo: ({
    recipient,
    token
  }: {
    recipient: string;
    token: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setIsLiquidator: ({
    account,
    value
  }: {
    account: string;
    value: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addRouter: ({
    router
  }: {
    router: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  buyUsdoCb: ({
    feeBasisPoints,
    mintAmount,
    recipient,
    token,
    tokenAmount
  }: {
    feeBasisPoints: Uint128;
    mintAmount: Uint128;
    recipient: Addr;
    token: Addr;
    tokenAmount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  clearTokenConfig: ({
    token
  }: {
    token: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  decreasePosition: ({
    account,
    collateralDelta,
    collateralToken,
    indexToken,
    isLong,
    recipient,
    sizeDelta
  }: {
    account: string;
    collateralDelta: Uint128;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
    recipient: string;
    sizeDelta: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  directPoolDeposit: ({
    token
  }: {
    token: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  increasePosition: ({
    account,
    collateralToken,
    indexToken,
    isLong,
    sizeDelta
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
    sizeDelta: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  liquidatePosition: ({
    account,
    collateralToken,
    feeRecipient,
    indexToken,
    isLong
  }: {
    account: string;
    collateralToken: string;
    feeRecipient: string;
    indexToken: string;
    isLong: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setRouter: ({
    router
  }: {
    router: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sellUsdo: ({
    recipient,
    token
  }: {
    recipient: string;
    token: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sellUsdoCb: ({
    recipient,
    redemptionAmount,
    token,
    usdoAmount
  }: {
    recipient: Addr;
    redemptionAmount: Uint128;
    token: Addr;
    usdoAmount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setFees: ({
    hasDynamicFees,
    liquidationFeeUsd,
    marginFeeBasisPoints,
    minProfitTime,
    mintBurnFeeBasisPoints,
    stableSwapFeeBasisPoints,
    stableTaxBasisPoints,
    swapFeeBasisPoints,
    taxBasisPoints
  }: {
    hasDynamicFees: boolean;
    liquidationFeeUsd: Uint128;
    marginFeeBasisPoints: Uint128;
    minProfitTime: Duration;
    mintBurnFeeBasisPoints: Uint128;
    stableSwapFeeBasisPoints: Uint128;
    stableTaxBasisPoints: Uint128;
    swapFeeBasisPoints: Uint128;
    taxBasisPoints: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setFundingRate: ({
    fundingInterval,
    fundingRateFactor,
    stableFundingRateFactor
  }: {
    fundingInterval: Duration;
    fundingRateFactor: Uint128;
    stableFundingRateFactor: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setTokenConfig: ({
    isShortable,
    isStable,
    maxUsdoAmount,
    minProfitBps,
    token,
    tokenDecimals,
    tokenWeight
  }: {
    isShortable: boolean;
    isStable: boolean;
    maxUsdoAmount: Uint128;
    minProfitBps: Uint128;
    token: string;
    tokenDecimals: number;
    tokenWeight: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setUsdoAmount: ({
    amount,
    token
  }: {
    amount: Uint128;
    token: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  swap: ({
    recipient,
    tokenIn,
    tokenOut
  }: {
    recipient?: string;
    tokenIn: string;
    tokenOut: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateCumulativeFundingRate: ({
    collateralToken,
    indexToken
  }: {
    collateralToken: string;
    indexToken: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawFees: ({
    recipient,
    token
  }: {
    recipient?: string;
    token: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setInManagerMode: ({
    inManagerMode
  }: {
    inManagerMode: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setInPrivateLiquidationMode: ({
    value
  }: {
    value: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setIsSwapEnabled: ({
    value
  }: {
    value: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setIsLeverageEnabled: ({
    value
  }: {
    value: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setMaxGasPrice: ({
    maxGasPrice
  }: {
    maxGasPrice: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setMaxGlobalShortPrice: ({
    token,
    value
  }: {
    token: string;
    value: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setManager: ({
    addr
  }: {
    addr: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setAdmin: ({
    newAdmin
  }: {
    newAdmin: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class OmxCwVaultClient extends OmxCwVaultQueryClient implements OmxCwVaultInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.buyUsdo = this.buyUsdo.bind(this);
    this.setIsLiquidator = this.setIsLiquidator.bind(this);
    this.addRouter = this.addRouter.bind(this);
    this.buyUsdoCb = this.buyUsdoCb.bind(this);
    this.clearTokenConfig = this.clearTokenConfig.bind(this);
    this.decreasePosition = this.decreasePosition.bind(this);
    this.directPoolDeposit = this.directPoolDeposit.bind(this);
    this.increasePosition = this.increasePosition.bind(this);
    this.liquidatePosition = this.liquidatePosition.bind(this);
    this.setRouter = this.setRouter.bind(this);
    this.sellUsdo = this.sellUsdo.bind(this);
    this.sellUsdoCb = this.sellUsdoCb.bind(this);
    this.setFees = this.setFees.bind(this);
    this.setFundingRate = this.setFundingRate.bind(this);
    this.setTokenConfig = this.setTokenConfig.bind(this);
    this.setUsdoAmount = this.setUsdoAmount.bind(this);
    this.swap = this.swap.bind(this);
    this.updateCumulativeFundingRate = this.updateCumulativeFundingRate.bind(this);
    this.withdrawFees = this.withdrawFees.bind(this);
    this.setInManagerMode = this.setInManagerMode.bind(this);
    this.setInPrivateLiquidationMode = this.setInPrivateLiquidationMode.bind(this);
    this.setIsSwapEnabled = this.setIsSwapEnabled.bind(this);
    this.setIsLeverageEnabled = this.setIsLeverageEnabled.bind(this);
    this.setMaxGasPrice = this.setMaxGasPrice.bind(this);
    this.setMaxGlobalShortPrice = this.setMaxGlobalShortPrice.bind(this);
    this.setManager = this.setManager.bind(this);
    this.setAdmin = this.setAdmin.bind(this);
  }

  buyUsdo = async ({
    recipient,
    token
  }: {
    recipient: string;
    token: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      buy_usdo: {
        recipient,
        token
      }
    }, fee, memo, _funds);
  };
  setIsLiquidator = async ({
    account,
    value
  }: {
    account: string;
    value: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_is_liquidator: {
        account,
        value
      }
    }, fee, memo, _funds);
  };
  addRouter = async ({
    router
  }: {
    router: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_router: {
        router
      }
    }, fee, memo, _funds);
  };
  buyUsdoCb = async ({
    feeBasisPoints,
    mintAmount,
    recipient,
    token,
    tokenAmount
  }: {
    feeBasisPoints: Uint128;
    mintAmount: Uint128;
    recipient: Addr;
    token: Addr;
    tokenAmount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      buy_usdo_cb: {
        fee_basis_points: feeBasisPoints,
        mint_amount: mintAmount,
        recipient,
        token,
        token_amount: tokenAmount
      }
    }, fee, memo, _funds);
  };
  clearTokenConfig = async ({
    token
  }: {
    token: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      clear_token_config: {
        token
      }
    }, fee, memo, _funds);
  };
  decreasePosition = async ({
    account,
    collateralDelta,
    collateralToken,
    indexToken,
    isLong,
    recipient,
    sizeDelta
  }: {
    account: string;
    collateralDelta: Uint128;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
    recipient: string;
    sizeDelta: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      decrease_position: {
        account,
        collateral_delta: collateralDelta,
        collateral_token: collateralToken,
        index_token: indexToken,
        is_long: isLong,
        recipient,
        size_delta: sizeDelta
      }
    }, fee, memo, _funds);
  };
  directPoolDeposit = async ({
    token
  }: {
    token: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      direct_pool_deposit: {
        token
      }
    }, fee, memo, _funds);
  };
  increasePosition = async ({
    account,
    collateralToken,
    indexToken,
    isLong,
    sizeDelta
  }: {
    account: string;
    collateralToken: string;
    indexToken: string;
    isLong: boolean;
    sizeDelta: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      increase_position: {
        account,
        collateral_token: collateralToken,
        index_token: indexToken,
        is_long: isLong,
        size_delta: sizeDelta
      }
    }, fee, memo, _funds);
  };
  liquidatePosition = async ({
    account,
    collateralToken,
    feeRecipient,
    indexToken,
    isLong
  }: {
    account: string;
    collateralToken: string;
    feeRecipient: string;
    indexToken: string;
    isLong: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      liquidate_position: {
        account,
        collateral_token: collateralToken,
        fee_recipient: feeRecipient,
        index_token: indexToken,
        is_long: isLong
      }
    }, fee, memo, _funds);
  };
  setRouter = async ({
    router
  }: {
    router: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_router: {
        router
      }
    }, fee, memo, _funds);
  };
  sellUsdo = async ({
    recipient,
    token
  }: {
    recipient: string;
    token: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      sell_usdo: {
        recipient,
        token
      }
    }, fee, memo, _funds);
  };
  sellUsdoCb = async ({
    recipient,
    redemptionAmount,
    token,
    usdoAmount
  }: {
    recipient: Addr;
    redemptionAmount: Uint128;
    token: Addr;
    usdoAmount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      sell_usdo_cb: {
        recipient,
        redemption_amount: redemptionAmount,
        token,
        usdo_amount: usdoAmount
      }
    }, fee, memo, _funds);
  };
  setFees = async ({
    hasDynamicFees,
    liquidationFeeUsd,
    marginFeeBasisPoints,
    minProfitTime,
    mintBurnFeeBasisPoints,
    stableSwapFeeBasisPoints,
    stableTaxBasisPoints,
    swapFeeBasisPoints,
    taxBasisPoints
  }: {
    hasDynamicFees: boolean;
    liquidationFeeUsd: Uint128;
    marginFeeBasisPoints: Uint128;
    minProfitTime: Duration;
    mintBurnFeeBasisPoints: Uint128;
    stableSwapFeeBasisPoints: Uint128;
    stableTaxBasisPoints: Uint128;
    swapFeeBasisPoints: Uint128;
    taxBasisPoints: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_fees: {
        has_dynamic_fees: hasDynamicFees,
        liquidation_fee_usd: liquidationFeeUsd,
        margin_fee_basis_points: marginFeeBasisPoints,
        min_profit_time: minProfitTime,
        mint_burn_fee_basis_points: mintBurnFeeBasisPoints,
        stable_swap_fee_basis_points: stableSwapFeeBasisPoints,
        stable_tax_basis_points: stableTaxBasisPoints,
        swap_fee_basis_points: swapFeeBasisPoints,
        tax_basis_points: taxBasisPoints
      }
    }, fee, memo, _funds);
  };
  setFundingRate = async ({
    fundingInterval,
    fundingRateFactor,
    stableFundingRateFactor
  }: {
    fundingInterval: Duration;
    fundingRateFactor: Uint128;
    stableFundingRateFactor: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_funding_rate: {
        funding_interval: fundingInterval,
        funding_rate_factor: fundingRateFactor,
        stable_funding_rate_factor: stableFundingRateFactor
      }
    }, fee, memo, _funds);
  };
  setTokenConfig = async ({
    isShortable,
    isStable,
    maxUsdoAmount,
    minProfitBps,
    token,
    tokenDecimals,
    tokenWeight
  }: {
    isShortable: boolean;
    isStable: boolean;
    maxUsdoAmount: Uint128;
    minProfitBps: Uint128;
    token: string;
    tokenDecimals: number;
    tokenWeight: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_token_config: {
        is_shortable: isShortable,
        is_stable: isStable,
        max_usdo_amount: maxUsdoAmount,
        min_profit_bps: minProfitBps,
        token,
        token_decimals: tokenDecimals,
        token_weight: tokenWeight
      }
    }, fee, memo, _funds);
  };
  setUsdoAmount = async ({
    amount,
    token
  }: {
    amount: Uint128;
    token: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_usdo_amount: {
        amount,
        token
      }
    }, fee, memo, _funds);
  };
  swap = async ({
    recipient,
    tokenIn,
    tokenOut
  }: {
    recipient?: string;
    tokenIn: string;
    tokenOut: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      swap: {
        recipient,
        token_in: tokenIn,
        token_out: tokenOut
      }
    }, fee, memo, _funds);
  };
  updateCumulativeFundingRate = async ({
    collateralToken,
    indexToken
  }: {
    collateralToken: string;
    indexToken: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_cumulative_funding_rate: {
        collateral_token: collateralToken,
        index_token: indexToken
      }
    }, fee, memo, _funds);
  };
  withdrawFees = async ({
    recipient,
    token
  }: {
    recipient?: string;
    token: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_fees: {
        recipient,
        token
      }
    }, fee, memo, _funds);
  };
  setInManagerMode = async ({
    inManagerMode
  }: {
    inManagerMode: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_in_manager_mode: {
        in_manager_mode: inManagerMode
      }
    }, fee, memo, _funds);
  };
  setInPrivateLiquidationMode = async ({
    value
  }: {
    value: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_in_private_liquidation_mode: {
        value
      }
    }, fee, memo, _funds);
  };
  setIsSwapEnabled = async ({
    value
  }: {
    value: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_is_swap_enabled: {
        value
      }
    }, fee, memo, _funds);
  };
  setIsLeverageEnabled = async ({
    value
  }: {
    value: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_is_leverage_enabled: {
        value
      }
    }, fee, memo, _funds);
  };
  setMaxGasPrice = async ({
    maxGasPrice
  }: {
    maxGasPrice: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_max_gas_price: {
        max_gas_price: maxGasPrice
      }
    }, fee, memo, _funds);
  };
  setMaxGlobalShortPrice = async ({
    token,
    value
  }: {
    token: string;
    value: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_max_global_short_price: {
        token,
        value
      }
    }, fee, memo, _funds);
  };
  setManager = async ({
    addr
  }: {
    addr: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_manager: {
        addr
      }
    }, fee, memo, _funds);
  };
  setAdmin = async ({
    newAdmin
  }: {
    newAdmin: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_admin: {
        new_admin: newAdmin
      }
    }, fee, memo, _funds);
  };
}