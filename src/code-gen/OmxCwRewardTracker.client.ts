/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Uint128, InstantiateMsg, MinterResponse, ExecuteMsg, Binary, Expiration, Timestamp, Uint64, Logo, EmbeddedLogo, QueryMsg, MigrateMsg, AllAccountsResponse, AllAllowancesResponse, AllowanceInfo, AllSpenderAllowancesResponse, SpenderAllowanceInfo, AllowanceResponse, BalanceResponse, DownloadLogoResponse, Boolean, LogoInfo, Addr, MarketingInfoResponse, RewardTrackerInitializedState, TokenInfoResponse } from "./OmxCwRewardTracker.types";
export interface OmxCwRewardTrackerReadOnlyInterface {
  contractAddress: string;
  balance: ({
    address
  }: {
    address: string;
  }) => Promise<BalanceResponse>;
  tokenInfo: () => Promise<TokenInfoResponse>;
  minter: () => Promise<MinterResponse>;
  allowance: ({
    owner,
    spender
  }: {
    owner: string;
    spender: string;
  }) => Promise<AllowanceResponse>;
  allAllowances: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }) => Promise<AllAllowancesResponse>;
  allSpenderAllowances: ({
    limit,
    spender,
    startAfter
  }: {
    limit?: number;
    spender: string;
    startAfter?: string;
  }) => Promise<AllSpenderAllowancesResponse>;
  allAccounts: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<AllAccountsResponse>;
  marketingInfo: () => Promise<MarketingInfoResponse>;
  downloadLogo: () => Promise<DownloadLogoResponse>;
  claimable: ({
    account
  }: {
    account: string;
  }) => Promise<Uint128>;
  depositBalance: ({
    account,
    token
  }: {
    account: string;
    token: string;
  }) => Promise<Uint128>;
  cumulativeRewards: ({
    account
  }: {
    account: string;
  }) => Promise<Uint128>;
  averageStakedAmount: ({
    account
  }: {
    account: string;
  }) => Promise<Uint128>;
  totalDepositSupply: ({
    token
  }: {
    token: string;
  }) => Promise<Uint128>;
  stakedAmount: ({
    account
  }: {
    account: string;
  }) => Promise<Uint128>;
  rewardToken: () => Promise<Addr>;
  initialized: () => Promise<Boolean>;
  isHandler: ({
    account
  }: {
    account: string;
  }) => Promise<Boolean>;
  isDepositToken: ({
    token
  }: {
    token: string;
  }) => Promise<Boolean>;
  rewardTrackerState: () => Promise<RewardTrackerInitializedState>;
}
export class OmxCwRewardTrackerQueryClient implements OmxCwRewardTrackerReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.balance = this.balance.bind(this);
    this.tokenInfo = this.tokenInfo.bind(this);
    this.minter = this.minter.bind(this);
    this.allowance = this.allowance.bind(this);
    this.allAllowances = this.allAllowances.bind(this);
    this.allSpenderAllowances = this.allSpenderAllowances.bind(this);
    this.allAccounts = this.allAccounts.bind(this);
    this.marketingInfo = this.marketingInfo.bind(this);
    this.downloadLogo = this.downloadLogo.bind(this);
    this.claimable = this.claimable.bind(this);
    this.depositBalance = this.depositBalance.bind(this);
    this.cumulativeRewards = this.cumulativeRewards.bind(this);
    this.averageStakedAmount = this.averageStakedAmount.bind(this);
    this.totalDepositSupply = this.totalDepositSupply.bind(this);
    this.stakedAmount = this.stakedAmount.bind(this);
    this.rewardToken = this.rewardToken.bind(this);
    this.initialized = this.initialized.bind(this);
    this.isHandler = this.isHandler.bind(this);
    this.isDepositToken = this.isDepositToken.bind(this);
    this.rewardTrackerState = this.rewardTrackerState.bind(this);
  }

  balance = async ({
    address
  }: {
    address: string;
  }): Promise<BalanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      balance: {
        address
      }
    });
  };
  tokenInfo = async (): Promise<TokenInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_info: {}
    });
  };
  minter = async (): Promise<MinterResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      minter: {}
    });
  };
  allowance = async ({
    owner,
    spender
  }: {
    owner: string;
    spender: string;
  }): Promise<AllowanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      allowance: {
        owner,
        spender
      }
    });
  };
  allAllowances = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }): Promise<AllAllowancesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_allowances: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  allSpenderAllowances = async ({
    limit,
    spender,
    startAfter
  }: {
    limit?: number;
    spender: string;
    startAfter?: string;
  }): Promise<AllSpenderAllowancesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_spender_allowances: {
        limit,
        spender,
        start_after: startAfter
      }
    });
  };
  allAccounts = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<AllAccountsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_accounts: {
        limit,
        start_after: startAfter
      }
    });
  };
  marketingInfo = async (): Promise<MarketingInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      marketing_info: {}
    });
  };
  downloadLogo = async (): Promise<DownloadLogoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      download_logo: {}
    });
  };
  claimable = async ({
    account
  }: {
    account: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      claimable: {
        account
      }
    });
  };
  depositBalance = async ({
    account,
    token
  }: {
    account: string;
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      deposit_balance: {
        account,
        token
      }
    });
  };
  cumulativeRewards = async ({
    account
  }: {
    account: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      cumulative_rewards: {
        account
      }
    });
  };
  averageStakedAmount = async ({
    account
  }: {
    account: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      average_staked_amount: {
        account
      }
    });
  };
  totalDepositSupply = async ({
    token
  }: {
    token: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_deposit_supply: {
        token
      }
    });
  };
  stakedAmount = async ({
    account
  }: {
    account: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      staked_amount: {
        account
      }
    });
  };
  rewardToken = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reward_token: {}
    });
  };
  initialized = async (): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      initialized: {}
    });
  };
  isHandler = async ({
    account
  }: {
    account: string;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_handler: {
        account
      }
    });
  };
  isDepositToken = async ({
    token
  }: {
    token: string;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_deposit_token: {
        token
      }
    });
  };
  rewardTrackerState = async (): Promise<RewardTrackerInitializedState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reward_tracker_state: {}
    });
  };
}
export interface OmxCwRewardTrackerInterface extends OmxCwRewardTrackerReadOnlyInterface {
  contractAddress: string;
  sender: string;
  initialize: ({
    distributor
  }: {
    distributor: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  transfer: ({
    amount,
    recipient
  }: {
    amount: Uint128;
    recipient: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  burn: ({
    amount
  }: {
    amount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  send: ({
    amount,
    contract,
    msg
  }: {
    amount: Uint128;
    contract: string;
    msg: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  increaseAllowance: ({
    amount,
    expires,
    spender
  }: {
    amount: Uint128;
    expires?: Expiration;
    spender: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  decreaseAllowance: ({
    amount,
    expires,
    spender
  }: {
    amount: Uint128;
    expires?: Expiration;
    spender: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  transferFrom: ({
    amount,
    owner,
    recipient
  }: {
    amount: Uint128;
    owner: string;
    recipient: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendFrom: ({
    amount,
    contract,
    msg,
    owner
  }: {
    amount: Uint128;
    contract: string;
    msg: Binary;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  burnFrom: ({
    amount,
    owner
  }: {
    amount: Uint128;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  mint: ({
    amount,
    recipient
  }: {
    amount: Uint128;
    recipient: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMinter: ({
    newMinter
  }: {
    newMinter?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMarketing: ({
    description,
    marketing,
    project
  }: {
    description?: string;
    marketing?: string;
    project?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  uploadLogo: (logo: Logo, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setAdmin: ({
    account
  }: {
    account: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setInPrivateTransferMode: ({
    value
  }: {
    value: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setInPrivateClaimingMode: ({
    value
  }: {
    value: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setInPrivateStakingMode: ({
    value
  }: {
    value: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setHandler: ({
    account,
    isHandler
  }: {
    account: string;
    isHandler: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setDepositToken: ({
    isDepositToken,
    token
  }: {
    isDepositToken: boolean;
    token: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  stake: ({
    amount,
    depositToken
  }: {
    amount: Uint128;
    depositToken: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  stakeForAccount: ({
    account,
    amount,
    depositToken,
    fundingAccount
  }: {
    account: string;
    amount: Uint128;
    depositToken: string;
    fundingAccount: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unstake: ({
    amount,
    depositToken
  }: {
    amount: Uint128;
    depositToken: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unstakeForAccount: ({
    account,
    amount,
    depositToken,
    recipient
  }: {
    account: string;
    amount: Uint128;
    depositToken: string;
    recipient: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateRewards: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claim: ({
    recipient
  }: {
    recipient: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claimForAccount: ({
    account,
    recipient
  }: {
    account: string;
    recipient: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class OmxCwRewardTrackerClient extends OmxCwRewardTrackerQueryClient implements OmxCwRewardTrackerInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.initialize = this.initialize.bind(this);
    this.transfer = this.transfer.bind(this);
    this.burn = this.burn.bind(this);
    this.send = this.send.bind(this);
    this.increaseAllowance = this.increaseAllowance.bind(this);
    this.decreaseAllowance = this.decreaseAllowance.bind(this);
    this.transferFrom = this.transferFrom.bind(this);
    this.sendFrom = this.sendFrom.bind(this);
    this.burnFrom = this.burnFrom.bind(this);
    this.mint = this.mint.bind(this);
    this.updateMinter = this.updateMinter.bind(this);
    this.updateMarketing = this.updateMarketing.bind(this);
    this.uploadLogo = this.uploadLogo.bind(this);
    this.setAdmin = this.setAdmin.bind(this);
    this.setInPrivateTransferMode = this.setInPrivateTransferMode.bind(this);
    this.setInPrivateClaimingMode = this.setInPrivateClaimingMode.bind(this);
    this.setInPrivateStakingMode = this.setInPrivateStakingMode.bind(this);
    this.setHandler = this.setHandler.bind(this);
    this.setDepositToken = this.setDepositToken.bind(this);
    this.stake = this.stake.bind(this);
    this.stakeForAccount = this.stakeForAccount.bind(this);
    this.unstake = this.unstake.bind(this);
    this.unstakeForAccount = this.unstakeForAccount.bind(this);
    this.updateRewards = this.updateRewards.bind(this);
    this.claim = this.claim.bind(this);
    this.claimForAccount = this.claimForAccount.bind(this);
  }

  initialize = async ({
    distributor
  }: {
    distributor: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      initialize: {
        distributor
      }
    }, fee, memo, _funds);
  };
  transfer = async ({
    amount,
    recipient
  }: {
    amount: Uint128;
    recipient: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer: {
        amount,
        recipient
      }
    }, fee, memo, _funds);
  };
  burn = async ({
    amount
  }: {
    amount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn: {
        amount
      }
    }, fee, memo, _funds);
  };
  send = async ({
    amount,
    contract,
    msg
  }: {
    amount: Uint128;
    contract: string;
    msg: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send: {
        amount,
        contract,
        msg
      }
    }, fee, memo, _funds);
  };
  increaseAllowance = async ({
    amount,
    expires,
    spender
  }: {
    amount: Uint128;
    expires?: Expiration;
    spender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      increase_allowance: {
        amount,
        expires,
        spender
      }
    }, fee, memo, _funds);
  };
  decreaseAllowance = async ({
    amount,
    expires,
    spender
  }: {
    amount: Uint128;
    expires?: Expiration;
    spender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      decrease_allowance: {
        amount,
        expires,
        spender
      }
    }, fee, memo, _funds);
  };
  transferFrom = async ({
    amount,
    owner,
    recipient
  }: {
    amount: Uint128;
    owner: string;
    recipient: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_from: {
        amount,
        owner,
        recipient
      }
    }, fee, memo, _funds);
  };
  sendFrom = async ({
    amount,
    contract,
    msg,
    owner
  }: {
    amount: Uint128;
    contract: string;
    msg: Binary;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_from: {
        amount,
        contract,
        msg,
        owner
      }
    }, fee, memo, _funds);
  };
  burnFrom = async ({
    amount,
    owner
  }: {
    amount: Uint128;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn_from: {
        amount,
        owner
      }
    }, fee, memo, _funds);
  };
  mint = async ({
    amount,
    recipient
  }: {
    amount: Uint128;
    recipient: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mint: {
        amount,
        recipient
      }
    }, fee, memo, _funds);
  };
  updateMinter = async ({
    newMinter
  }: {
    newMinter?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_minter: {
        new_minter: newMinter
      }
    }, fee, memo, _funds);
  };
  updateMarketing = async ({
    description,
    marketing,
    project
  }: {
    description?: string;
    marketing?: string;
    project?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_marketing: {
        description,
        marketing,
        project
      }
    }, fee, memo, _funds);
  };
  uploadLogo = async (logo: Logo, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      upload_logo: logo
    }, fee, memo, _funds);
  };
  setAdmin = async ({
    account
  }: {
    account: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_admin: {
        account
      }
    }, fee, memo, _funds);
  };
  setInPrivateTransferMode = async ({
    value
  }: {
    value: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_in_private_transfer_mode: {
        value
      }
    }, fee, memo, _funds);
  };
  setInPrivateClaimingMode = async ({
    value
  }: {
    value: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_in_private_claiming_mode: {
        value
      }
    }, fee, memo, _funds);
  };
  setInPrivateStakingMode = async ({
    value
  }: {
    value: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_in_private_staking_mode: {
        value
      }
    }, fee, memo, _funds);
  };
  setHandler = async ({
    account,
    isHandler
  }: {
    account: string;
    isHandler: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_handler: {
        account,
        is_handler: isHandler
      }
    }, fee, memo, _funds);
  };
  setDepositToken = async ({
    isDepositToken,
    token
  }: {
    isDepositToken: boolean;
    token: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_deposit_token: {
        is_deposit_token: isDepositToken,
        token
      }
    }, fee, memo, _funds);
  };
  stake = async ({
    amount,
    depositToken
  }: {
    amount: Uint128;
    depositToken: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      stake: {
        amount,
        deposit_token: depositToken
      }
    }, fee, memo, _funds);
  };
  stakeForAccount = async ({
    account,
    amount,
    depositToken,
    fundingAccount
  }: {
    account: string;
    amount: Uint128;
    depositToken: string;
    fundingAccount: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      stake_for_account: {
        account,
        amount,
        deposit_token: depositToken,
        funding_account: fundingAccount
      }
    }, fee, memo, _funds);
  };
  unstake = async ({
    amount,
    depositToken
  }: {
    amount: Uint128;
    depositToken: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unstake: {
        amount,
        deposit_token: depositToken
      }
    }, fee, memo, _funds);
  };
  unstakeForAccount = async ({
    account,
    amount,
    depositToken,
    recipient
  }: {
    account: string;
    amount: Uint128;
    depositToken: string;
    recipient: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unstake_for_account: {
        account,
        amount,
        deposit_token: depositToken,
        recipient
      }
    }, fee, memo, _funds);
  };
  updateRewards = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_rewards: {}
    }, fee, memo, _funds);
  };
  claim = async ({
    recipient
  }: {
    recipient: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim: {
        recipient
      }
    }, fee, memo, _funds);
  };
  claimForAccount = async ({
    account,
    recipient
  }: {
    account: string;
    recipient: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_for_account: {
        account,
        recipient
      }
    }, fee, memo, _funds);
  };
}